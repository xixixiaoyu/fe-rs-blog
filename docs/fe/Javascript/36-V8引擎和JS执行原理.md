## 361.浏览器工作原理

> 当我们输入域名址会由 DNS 解析成 IP 地址，然后到对应服务器请求 index.html
>
> 解析当前 index.html 的时候遇见 css、js、img 等文件会继续前往服务器下载相关文件

## 2.浏览器的内核

| chrome  | Blink   |
| ------- | ------- |
| Opera   | Blink   |
| IE      | Trident |
| Safari  | webkit  |
| firefox | Gecko   |

浏览器内核分或两部分:`渲染引擎`和`JS引擎`。

`渲染染引擎`：将代码转换成页面输出到浏览器界面。

`JS引擎`：解析和执行 javascript 来实现网页的动态效果。

最开始渲染引擎和 Js 引擎并没有区分得很明确，后来 JS 引擎越来越独，内核就倾向于只指渲染引擎、也称为排版引擎（layout engine）、浏览器引擎（browser engine）、页面渲染引擎（rendering engine）。

## 3.浏览器渲染过程

![image-20220206231636527](https://raw.githubusercontent.com/xixixiaoyu/CloundImg2/main/image-20220206231636527.png)

当我们 HTML 解析时遇见 script 标签会停止解析转而去通过 JavaScript 引擎加载执行 JavaScript 代码

## 4.JavaScript 引擎

> 高级的编程语言都是需要转成最终的机器指令来执行的
>
> 所以上我们编写的 JavaScript 无论交给浏览器或者 Node 执行，最后都是需要被 CPU 执行的
>
> 但是 CPU 只认识自己的指令集，实际上是机器语言，才能被 CPU 所执行
>
> 所以我们需要 JavaScript 引擎帮助我们将 JavaScript 代码翻译成 CPU 指令来执行
>
> 最强大的 JavaScript 引擎当属 Google 开发的 V8

## 5.浏览器内核和 JS 引擎的关系

> 以 WebKit 为例，WebKit 事实上由两部分组成的：
>
> - WebCore：负责 HTML 解析、布局、渲染等等相关的工作
> - JavaScriptCore：解析、执行 JavaScript 代码
>
> 小程序编写的 JavaScript 代码实际也是被 JSCore 执行的

<img src="https://raw.githubusercontent.com/xixixiaoyu/CloundImg2/main/image-20220206233830495.png" alt="image-20220206233830495" style="zoom: 67%;" />

## 6.V8 引擎

> V8 是用 C ++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Node.js 等
>
> V8 可以独立运行，也可以嵌入到任何 C ++应用程序中

### 底层解析过程

![image-20220206234121678](https://raw.githubusercontent.com/xixixiaoyu/CloundImg2/main/image-20220206234121678.png)

### 架构

> V8 引擎本身的源码非常复杂，大概有超过 100w 行 C++代码，我们可以学习其架构更好了解 JS 执行
>
> **Parse 模块**会将 JavaScript 代码转换成 AST（抽象语法树）
>
> - 这是因为解释器并不直接认识 JavaScript 代码，如果函数没有被调用，那么是不会被转换成 AST 的，
>
> **Ignition 解释器**，会将 AST 转换成 ByteCode（字节码）
>
> - 同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）
> - 如果函数只调用一次，Ignition 会执行解释执行 ByteCode
>
> **TurboFan 编译器**，可以将字节码编译为 CPU 可以直接执行的机器码
>
> - 如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能
> - 但是，机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码

### 官方解析图

![image-20220207001548721](https://raw.githubusercontent.com/xixixiaoyu/CloundImg2/main/image-20220207001548721.png)

> Blink 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换
>
> Scanner 会进行词法分析（lexical analysis），词法分析会将代码转换成 tokens
>
> 接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser：
>
> - Parser 就是直接将 tokens 转成 AST 树架构
> - PreParser 则是预解析
>   - 因为不是所有 Javascript 代码在一开始必须全部解析执行，这样会影响网页运行效率
>   - 所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析是在函数被调用时才会进行
>   - 比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析
>
> 生成 AST 树后，会被 Ignition 转成字节码（bytecode）匹配对应平台 CPU 指令进行代码执行

## 7.一段代码如何解析？

> 当 js 引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）
>
> - 该对象 所有的作用域（scope）都可以访问
> - 里面会包含 Date、Array、String、Number、setTimeout、setInterval 等等
> - 其中还有一个 window 属性指向自己
>
> js 引擎内部有一个执行上下文栈（Execution Context Stack，简称 ECS），它是用于执行代码的调用栈
>
> 当它执行全局代码块的时候会构建一个全局执行上下文 Global Execution Context（GEC）
>
> GEC 会 被放入到 ECS 中 执行，其中包含两部分内容
>
> - 第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中， 但是并不会赋值，此过程也叫变量的作用域提升（hoisting）
> - 第二部分：在代码执行中，对变量赋值，或者执行其他的函数
>
> 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context， 简称 FEC），并且压入到 EC Stack 中
>
> FEC 中包含三部分内容：
>
> - 第一部分：在解析函数成为 AST 树结构时，会创建一个 Activation Object（AO）
>   - AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量
> - 第二部分：作用域链：由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找
> - 第三部分：根据不同情况 this 绑定值
