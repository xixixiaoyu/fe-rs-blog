### 探索 Next.js 的完整路由缓存与路由缓存：性能优化的双刃剑

在现代 Web 开发中，性能优化是一个永恒的话题，而缓存机制无疑是提升性能的关键工具之一。今天，我们将深入探讨 Next.js 中的 **完整路由缓存** 和 **路由缓存**，看看它们是如何在幕后工作，又该如何在项目中灵活运用。

#### 1. 完整路由缓存：让静态渲染更高效

**完整路由缓存** 是 Next.js 在构建时自动生成的缓存机制。它的工作原理是：在构建时，Next.js 会将静态渲染的路由生成的 **RSC Payload**（React Server Component Payload）和 **HTML** 缓存起来。这样，当用户访问这些路由时，服务器可以直接返回缓存的内容，而不需要重新渲染页面。

##### 1.1. 工作原理

Next.js 的渲染过程分为两步：

1. **生成 RSC Payload**：这是服务端组件的渲染结果，包含了组件的结构、数据以及客户端组件的占位符。
2. **生成 HTML**：Next.js 会将 RSC Payload 和客户端组件的代码结合，生成最终的 HTML 页面。

举个例子，假设我们有一个简单的服务端组件：

```jsx
<div>
  Don’t give up and don’t give in.
  <ClientComponent />
</div>
```

Next.js 会将其转换为 RSC Payload：

```json
["$","div",null,{"children":["Don’t give up and don’t give in.", ["$","$L1",null,{}]]}]
1:I{"id":123,"chunks":["chunk/[hash].js"],"name":"ClientComponent","async":false}
```

这个 RSC Payload 包含了服务端组件的渲染结果和客户端组件的占位符。客户端在接收到这个 Payload 后，会根据占位符加载相应的客户端组件，并将其渲染到页面中。

##### 1.2. 持续时间与失效方式

完整路由缓存是持久的，意味着它可以跨用户请求复用。然而，它也有失效的情况：

- **重新验证数据**：如果数据缓存被重新验证，完整路由缓存也会失效。
- **重新部署**：每次重新部署时，完整路由缓存会被清除。

##### 1.3. 如何退出完整路由缓存？

如果你不希望使用完整路由缓存，可以通过以下方式退出：

- **动态渲染**：使用 `dynamic = 'force-dynamic'` 或 `revalidate = 0`，可以强制路由每次都重新渲染。
- **退出数据缓存**：如果某个 `fetch` 请求设置为不缓存（如 `cache: 'no-store'`），那么完整路由缓存也会失效。

#### 2. 路由缓存：提升用户导航体验

**路由缓存** 是 Next.js 在客户端的缓存机制。它会在用户会话期间，将访问过的路由段的 RSC Payload 缓存到内存中，从而加快后续的导航速度。

##### 2.1. 工作原理

当用户首次访问某个路由时，Next.js 会将该路由的 RSC Payload 缓存起来。后续访问相同的路由时，Next.js 会直接从缓存中读取数据，而不需要重新发起请求。

此外，Next.js 还会预加载用户可能访问的路由。例如，当页面中有 `<Link>` 组件时，Next.js 会自动预加载这些链接对应的路由段，进一步提升导航体验。

##### 2.2. 持续时间与失效方式

路由缓存的持续时间取决于路由的渲染方式：

- **静态渲染**：缓存持续 5 分钟。
- **动态渲染**：缓存持续 30 秒。

路由缓存可以通过以下方式失效：

- **重新验证数据**：通过 `revalidatePath` 或 `revalidateTag` 重新验证数据。
- **修改 cookies**：如果路由依赖于 cookies，修改 cookies 会使路由缓存失效。
- **调用 `router.refresh`**：手动刷新当前路由，强制重新获取数据。

##### 2.3. 无法完全退出路由缓存

需要注意的是，**路由缓存无法完全退出**。即使你禁用了 `<Link>` 组件的预加载功能，Next.js 仍然会在用户会话期间缓存路由段 30 秒。这是为了确保嵌套路由之间的即时导航体验。

#### 3. 实战：路由缓存的利与弊

虽然路由缓存可以显著提升用户的导航体验，但在某些场景下，它也可能带来一些困扰。让我们通过一个简单的项目来感受一下。

##### 3.1. 项目结构

```plaintext
app
├─ (cache)
│  ├─ about
│  │  └─ page.js
│  ├─ settings
│  │  └─ page.js
│  ├─ layout.js
│  └─ loading.js
```

在这个项目中，我们有两个页面 `/about` 和 `/settings`，它们共享一个布局。每个页面在加载时都会模拟一个 2 秒的延迟。

##### 3.2. 路由缓存的表现

当我们首次访问 `/about` 时，页面会显示加载状态（`loading`），然后显示内容。同样，首次访问 `/settings` 时也会显示加载状态。然而，当我们再次点击 `/about` 或 `/settings` 时，页面不再显示加载状态，甚至没有发起新的网络请求。这就是路由缓存的功效。

##### 3.3. 如何解决缓存问题？

如果你希望每次点击时都重新加载页面，可以尝试以下几种方式：

1. **等待缓存失效**：路由缓存会在 30 秒后自动失效，等待一段时间后再点击，页面会重新加载。
2. **使用原生 `<a>` 标签**：替换 `<Link>` 组件为 `<a>` 标签，强制页面刷新。
3. **调用 `router.refresh`**：在布局中使用 `router.refresh` 手动刷新路由。
4. **使用 `NavigationEvents` 组件**：监听路由变化，并在每次导航时刷新页面。

#### 4. 总结

**完整路由缓存** 和 **路由缓存** 是 Next.js 提供的两种强大的缓存机制，它们各自有不同的应用场景：

- **完整路由缓存**：适用于静态渲染的路由，缓存 RSC Payload 和 HTML，提升服务器端性能。
- **路由缓存**：适用于客户端的路由导航，缓存 RSC Payload，提升用户的导航体验。

在实际项目中，缓存机制可以显著提升性能，但也可能带来一些调试上的困扰。理解缓存的工作原理，并根据项目需求灵活配置缓存策略，才能真正发挥它的威力。
