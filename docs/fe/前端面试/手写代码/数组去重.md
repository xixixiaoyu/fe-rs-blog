## 什么是数组去重？

数组去重是指移除数组中的重复元素，只保留唯一值。例如将 `[1, 2, 2, 3, 4, 4, 5]` 转换为 `[1, 2, 3, 4, 5]`。这在前端开发中是一个非常常见的需求。



## 常用的数组去重方法

### 1. 使用 ES6 的 Set 对象（最推荐）

```javascript
function uniqueArray(arr) {
  return [...new Set(arr)];
}

// 或者更简洁的箭头函数写法
const uniqueArray = arr => [...new Set(arr)];

// 示例
const array = [1, 2, 2, 3, 4, 4, 5];
console.log(uniqueArray(array)); // [1, 2, 3, 4, 5]
```

**优点**：简洁高效，性能较好（时间复杂度 O(n)）
**缺点**：需要 ES6 环境支持



### 2. 使用 indexOf 或 includes 方法

```javascript
function uniqueArray(arr) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i]);
    }
  }
  return result;
}
```

**优点**：兼容性好，适用于所有 JavaScript 环境
**缺点**：性能较差（时间复杂度 O(n²)）



### 3. 使用 filter 方法结合 indexOf

```javascript
function uniqueArray(arr) {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index;
  });
}
```

**优点**：代码简洁，易于理解
**缺点**：性能不如 Set 方法（时间复杂度 O(n²)）



### 4. 使用对象/Map 哈希表

```javascript
function uniqueArray(arr) {
  const obj = {};
  return arr.filter(item => {
    return obj.hasOwnProperty(item) ? false : (obj[item] = true);
  });
}

// 使用 Map
function uniqueArrayWithMap(arr) {
  const map = new Map();
  return arr.filter(item => !map.has(item) && map.set(item, 1));
}
```

**优点**：性能较好（时间复杂度 O(n)）
**缺点**：对非原始类型（如对象）处理有局限性



### 5. 使用 reduce 方法

```javascript
function uniqueArray(arr) {
  return arr.reduce((prev, curr) => {
    return prev.includes(curr) ? prev : [...prev, curr];
  }, []);
}
```

**优点**：函数式风格，代码优雅
**缺点**：性能一般（时间复杂度 O(n²)）



## 特殊情况处理

### 对象数组去重

当数组元素是对象时，通常需要指定比较的属性：

```javascript
function uniqueObjectArray(arr, key) {
  const map = new Map();
  return arr.filter(item => !map.has(item[key]) && map.set(item[key], 1));
}

// 示例
const users = [
  {id: 1, name: '张三'},
  {id: 2, name: '李四'},
  {id: 1, name: '张三'} // 重复的id
];
console.log(uniqueObjectArray(users, 'id')); // 保留id唯一的对象
```

### 不区分数据类型的去重

如果要将字符串 "1" 和数字 1 视为不同：

```javascript
function uniqueStrictArray(arr) {
  const obj = {};
  return arr.filter(item => {
    const key = typeof item + JSON.stringify(item);
    return obj.hasOwnProperty(key) ? false : (obj[key] = true);
  });
}
```



## 性能比较和选择建议

1. **小型数组**：任何方法都可以，选择代码可读性高的
2. **中大型数组**：优先选择 Set 或 Map/对象方法
3. **需要兼容旧浏览器**：使用 indexOf 或 filter 方法
4. **处理复杂对象**：使用自定义比较函数的方法

在现代前端开发中，推荐使用 `[...new Set(arr)]` 作为首选方案，简洁高效且易于理解。



## 注意事项

- **NaN 的处理**：在 JavaScript 中，`NaN !== NaN`，但 Set 可以正确去重 NaN
- **引用类型**：对象即使内容相同，引用不同也会被视为不同元素
- **-0 和 +0**：在 Set 中被视为相同值
- **大数据量**：处理超大数组时，考虑分批处理避免性能问题

以上就是前端开发中常用的数组去重方法，根据实际需求选择最合适的方法即可。