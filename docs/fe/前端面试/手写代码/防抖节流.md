## **为什么需要防抖和节流？**

在前端开发中，有些操作会频繁触发，比如：

1. 用户疯狂点击按钮。
2. 页面滚动时触发的 `scroll` 事件。
3. 输入框输入文字时触发的 `input` 事件。

这些高频触发的事件如果每次都直接处理，可能会导致性能问题，比如页面卡顿、响应变慢，甚至崩溃。这时候，防抖和节流就派上用场了。它们的作用就是限制某些操作的执行频率，避免资源被过度占用。



## 什么是防抖和节流？

想象一下日常生活中的例子：

- **防抖**就像电梯门：你进去后，电梯会等待几秒才关门。如果这期间又有人进来，它会重新计时。只有真正没人进来了，电梯才会关门。
- **节流**就像游戏中的技能冷却：你释放一次技能后，必须等待一段时间才能再次使用，无论你怎么猛按键盘。



## 防抖(Debounce)

### 概念
防抖的核心是：**等待一段时间后才执行函数，如果这段时间内又触发了，就重新计时**。

### 实际应用
- 搜索框输入：用户输入停止后才发起请求
- 窗口调整：调整结束后才重新计算布局
- 按钮提交：防止用户快速多次点击

### 代码实现

```javascript
function debounce(fn, delay = 300) {
  let timer = null
  
  return function(...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 使用示例
const handleSearch = debounce(function(e) {
  console.log('搜索内容：', e.target.value)
}, 500)

searchInput.addEventListener('input', handleSearch)
```



## 节流(Throttle)

### 概念
节流的核心是：**在一段时间内，无论触发多少次，只执行一次函数**。

### 实际应用
- 滚动事件：控制滚动时的计算频率
- 游戏中的移动：限制角色移动更新频率
- 频繁点击：控制事件响应频率

### 代码实现

```javascript
function throttle(fn, interval = 300) {
  let lastTime = 0
  
  return function(...args) {
    const now = Date.now()
    
    if (now - lastTime >= interval) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用示例
const handleScroll = throttle(function() {
  console.log('滚动位置：', window.scrollY)
}, 200)

window.addEventListener('scroll', handleScroll)
```



## 两者的区别

- **防抖**：连续触发只执行最后一次（或第一次）
- **节流**：连续触发，按时间间隔执行



## 实际项目中如何选择？

- 需要等待用户操作完成后再执行？用**防抖**（如表单提交、搜索）
- 需要限制操作频率？用**节流**（如滚动加载、拖拽）

有没有发现？这两个技术其实挺简单的，但效果特别好，能让你的页面响应更加平滑，用户体验也会提升不少！

需要注意的是，现在很多库（如 Lodash）已经提供了这些功能的实现，在实际开发中可以直接使用，不必重复造轮子。
