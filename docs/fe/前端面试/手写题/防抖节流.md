### 为什么需要防抖和节流？

先想象一个场景：你在做一个搜索框，用户一边输入一边联想出结果。如果用户快速打字输入“hello”，每敲一个字母就发一次请求，那短短一秒钟可能就触发了五次请求。后端服务器会忙得晕头转向，浏览器也可能卡住。其实，我们真正想要的只是用户输入完“hello”后的那一次结果，对吧？

这时候，防抖和节流就登场了。它们的核心目的就是**减少不必要的频繁操作**，让程序跑得更顺畅。

防抖是“等一等再做事”，节流是“按节奏做事”。



### 防抖（Debounce）

#### 1. 什么是防抖？
防抖的意思是，当一个事件被频繁触发时，我们不急着立刻响应，而是等它停下来一段时间后再执行。

比如，用户在输入框里敲字，只要他还在敲，我们就按兵不动，等他停下几百毫秒后，才去处理。

#### 2. 怎么实现？	
实现防抖的思路很简单：
- 用一个定时器（`setTimeout`）来“拖延”执行。
- 每次事件触发时，先把之前的定时器清掉，然后重新设一个。
- 如果在等待时间内又有新的事件进来，就继续清掉重设；如果没动静了，定时器到期后就执行。

看看代码吧：
```javascript
function debounce(fn, delay = 300) {
  let timer = null
  return function (...args) {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 用法示例
const search = () => console.log('开始搜索！')
input.addEventListener('input', debounce(search, 500))
```

这里，`debounce` 包装了一个函数 `fn`，每次输入时都会重置定时器。只有当用户停止输入 500 毫秒后，`search` 才会执行。简单吧？

#### 3. 用在哪儿？
- **搜索框联想**：用户输入完再发请求，避免中间的无效操作。
- **窗口调整**：调整窗口大小结束时再重新计算布局。
- **表单提交**：用户填完信息停下来时再校验。



### 节流（Throttle）

#### 1. 啥是节流？
节流的意思是，不管事件触发得多频繁，我们都强制规定一个节奏，比如每秒最多执行一次。就像水龙头限流，不管你怎么拧，每秒钟只能流出一升水。

拿游戏来比喻更好理解：你玩游戏时有个技能，冷却时间是 3 秒，哪怕你狂按按钮，它也只能每 3 秒放一次。节流就是这个思路——有规律地执行。

#### 2. 怎么实现？
节流的实现靠的是时间戳：
- 记录上一次执行的时间。
- 每次事件触发时，检查现在的时间和上次执行的时间差。
- 如果差值超过了设定的间隔，就执行一次，并更新时间戳。

代码长这样：
```javascript
function throttle(fn, interval = 300) {
  let lastTime = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastTime >= interval) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 用法示例
const scrollHandler = () => console.log('滚动加载！')
window.addEventListener('scroll', throttle(scrollHandler, 1000))
```

这个 `throttle` 函数确保 `scrollHandler` 每 1000 毫秒（1 秒）最多执行一次，不管你滚动得多快。

#### 3. 用在哪儿？
- **滚动加载**：页面滚动时定期加载更多内容。
- **鼠标移动**：追踪鼠标位置，但不用每毫秒都更新。
- **拖拽元素**：实时更新位置，但控制频率。



### 四、防抖和节流有啥不一样？

防抖和节流虽然都是优化高频事件的，但思路和效果完全不同。咱们用个表格对比一下：

| 特点         | 防抖（Debounce）         | 节流（Throttle）       |
| ------------ | ------------------------ | ---------------------- |
| **触发频率** | 高频触发只认最后一次     | 高频触发按节奏稀释     |
| **执行时机** | 等事件停下来才执行       | 固定时间间隔内执行     |
| **生活例子** | 电梯关门，等没人再进     | 水龙头限流，匀速放水   |
| **适用场景** | 搜索框输入、窗口调整结束 | 滚动加载、鼠标移动跟踪 |

简单说：
- **防抖**适合“等结果”的场景，用户停下来再做事。
- **节流**适合“持续反馈”的场景，按节奏做事。



### 五、怎么选？看需求！

选择防抖还是节流，主要看你的需求：
1. **想要最终结果**：用防抖。比如用户输入完再搜索，或者窗口调整完再重绘。
2. **需要实时反馈**：用节流。比如拖拽元素时要更新位置，或者滚动时要加载内容。
3. **动画相关**：可以用现代浏览器的 `requestAnimationFrame`，它比传统节流更适合处理动画，性能更好。

举个例子：
- 用户拖动一个方块显示坐标，用节流，每 100 毫秒更新一次，流畅又不卡。
- 用户输入用户名检查是否重复，用防抖，等输入停下再查，避免多余请求。
