### 定位(position)(确定元素的位置)

定位是一种更高级的布局手段

​	通过定位可以将元素把摆放在页面的任意位置

​	 使用position属性来设置定位来设置定位

​				可选值

​							static 默认值                                                                                                                 元素是静止的没有开启定位

​							relative  开启元素的相对定位

​							absoluted  开启元素的绝对定位

​							fixed  开启元素的固定定位

 							position: sticky;  磁贴定位/粘性定位

### 静态定位(static) 

> static，无特殊定位，它是html元素默认的定位方式.
>
> 即我们不设定元素的position属性时默认的position值就是static，它遵循正常的文档流对象.
>
> 该定位方式下,top,right,bottom,left,z-index等属性是无效的。

### 相对定位(position:relative)

- 盒子可以相对**自己原来的位置**进行位置调整,称为相对定位


我们以前学过几种布局方式

> 浮动  从左往右依次排列
>
> 正常布局  从上往下依次排
>
> display:inline-block  看上去水平排列,本质上还是文本,有解析空格和垂直对齐的问题

**1.参照物:用来确定物体位置的原点**

**2.根据参照物，进行位置**

####  位置描述词

- left向右移动; right向左移动; top向下移动; bottom向上移动
- 值可以为负数，即往规定方向相反移动
- 多个位置偏移量出现  左上为尊（方向优先级）

```html
<style>
    *{
        margin: 0;
        padding: 0;
    }
    div{
        width: 400px;
        height: 400px;
        border: 1px solid #000;
        margin: 40px auto;
    }
    p {
        width: 100px;
        height: 100px;
        background-color: orange;
        position: relative;
        top: 100px;
        left: 100px;
    }
</style>
<div>
    <p></p>
</div>
```



**相对定位的特点**

​				1.元素开启相对定位后,如果不设置偏移量元素不会发生任何的变化

​				2.相对定位参照元素在文档流中自身的位置进行定位

​				4.相对定位不会脱离文档流,相对移动的时候,不会影响其他元素布局,只					是这个盒子表现在页面的位置发生了改变.

​				5.相对定位不会改变元素的性质，块还是块，行内还是行内

​				6.相对定位会提升元素的层级





#### 相对定位的用途

- 相对定位用来微调元素位置
- 相对定位的元素，可以当做绝对定位的参考盒子

```html
<style>
    *{
        margin: 0;
        padding: 0;
    }
    nav {
        width: 960px;
        height: 40px;
        margin: 40px auto;
    }
    nav ul {
        list-style: none;
    }
    nav ul li{
        float: left;
        width: 120px;
        height: 40px;
        text-align: center;
        line-height: 40px;
    }
    nav ul li a {
        display: block;
        width: 120px;
        height: 40px;
        background-color: orange;
        color: white;
        text-decoration: none;
    }
    nav ul li a:hover {
        border-top: 3px solid red;
        position: relative;
        top: -3px;
        background-color: gold;
    }
</style>
<nav>
    <ul>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
        <li>
            <a href="">网站栏目</a>
        </li>
    </ul>
</nav>
```



------

### 绝对定位(position:absolute)

> 绝对定位的位置参照物坐标:标志性建筑物
>
> 请先去参照物的位置,然后从这个位置出发,找到目标位置.
>



**绝对定位的参照物特点**

> 有定位属性的最近的祖先(父级/父级的父级/父级的父级的父级)元素,
>
> **有定位属性就**代表position:relative/position/fixed(有这其中一个,才能被子元素所参照)
>
> 最近一层一层往外面去寻找父级最终找到body
>
> 绝对定位的写法特点
>
> 父相子绝
>
> 父亲设置相对定位,子元素设置绝对定位相对于父亲去移动自身的位置.

#### 位置描述词

- left到左边的距离; right到右边的距离; top到上边的距离; bottom到下边的距离
- 一般为px 如果为百分比则相对于盒子的宽高

> 偏移量相对于参照父级的padding-box来计算位置.(包含padding不包含border)来进行计算的
>
> 绝对定位元素会脱离文档流,不保留位置,将释放自己的位置，对其他元素不会产生任何干扰，而是对它们进行压盖，
>
> 同级绝对定位盒子叠加,后写的在上面 
>
> 块级化:将元素强行转化为块级元素,它具有块元素的所有性质,但是不具有父元素宽度100%的特性,而是由里面的元素撑开的,
>
> 绝对定位会让浮动失效







### 固定定位(position:fixed)

> 我们又叫它牛皮糖,扫地阿姨搞半天都刮不下来,无论怎么搞它就在那里.
>
> 我们网页上也有这样的牛皮糖.就好像粘在你的屏幕上一样.怎么动它就在那里.
>
> 这与绝对定位的工作方式完全相同，只有一个**主要区别**：
>
> 绝对定位的固定元素是相对于HTML元素或其最近的定位祖先.
>
> **而固定定位的固定元素则是相对于浏览器视口本身。** 
>
> 固定定位元素不会随着网页滚动条滚动而滚动
>
> 固定定位的用途:“ 返回顶部”，"楼层导航

```css
		body{
			height: 2000px;
		}
		span{
			position: fixed;
			right: 0;
			bottom: 0;
			width: 100px;
			height: 100px;
			background-color: skyblue;	
		}
	<span>是兄弟就来砍我</span>

/*固定定位参照绝对定位理解,同样有块状化,脱离文档流等等特点.
  就是除了参照物的不同其他几乎相同.*/
```

------

### 七层层叠结构

> **背景层**
>
> 最底层的东西,背景就好像你给墙涂上油漆贴上墙纸,最后去挂画的时候,你见过把画挂在墙纸里面的吗?
>
> **==> 块级元素(block)层级 ==>  float浮动层 ==》 文本(inline/inline-block)层级  ==>  position定位层级**
>
> 定位层级就如何一个图钉去钉在某些元素上面一样.
>
> 这里只有5层层叠结构,这里position层级因为有z-index的参与而变得不同,
>
> 同样是定位层级,后写的元素同样会盖住先写的元素,
>
> 如果我们想修改元素的覆盖关系的时候,我们需要去修改HTML结构.
>
> 但是如果有一叠钞票,一张叠着一张的,我们这时想要放在下面的第二张钞票的时候,第二张钞票就凸显出来.怎么办呢?
>
> 那就必须比第一张高,怎么比第一张高.
>
> 我们就需要动态的去调整层级关系.Z-index控制定位元素谁高谁低的操作.
>
> `z-index`属性值并不是在任何元素上都有效果。
>
> 它**仅在**定位元素（定义了`position`属性，且属性值为非`static`值的元素）上有效果。
>
> 判断元素在`Z轴`上的堆叠顺序，不仅仅是直接比较两个元素的`z-index`值的大小，这个堆叠顺序实际由元素的**层叠上下文**、**层叠等级**共同决定。
>
> **z-index默认为0(auto),**
>
> **可以大于等于0的正整数  数值越大越层级越高,只在定位元素内生效**
>
> **也是可以写小于0的负整数,层级是最低的.**

```css
		ul{
			width: 600px;
			height: 600px;
			margin: 100px auto 0;
			border: 2px solid pink;
		}
		.bro1{
			height: 200px;
			background-color: skyblue;
		}
		.bro2{
			margin-top:-100px;
			height: 200px;
			background-color: lightgreen;
		}
		.bro3{
			margin-top:-100px;
			height:200px;
			background-color: pink;
		}
 	<ul>
        <li class="bro1">1</li>
        <li class="bro2">2</li>
        <li class="bro3">3</li>
    </ul>
	/*此时2的一部分在1的下面,3的一部分在2的下面.像不像叠着的钞票?
	  如果我们想让我们鼠标悬浮在哪个元素哪个元素就露出来*/
```

```css
li:hover{position:relative;}
	/*鼠标放上去的时候元素层级变高了
	  但是如果这些元素全部都写上了position:relative呢?*/
```

```css
li{position:relative;}
/*就不能控制元素显示的高低了.
  我们就可以去使用z-index*/
```

```css
li:hover{z-index: 1;}
/*当鼠标悬浮在上面的时候.层级就发生改变
  此时我们写上z-index为0,元素显示不会发生改变,说明默认确实是0*/
```

假如我们z-index写上负数呢?

```css
li:hover{z-index: -1;}
/*当我们鼠标放到元素上就会被其它元素盖住*/
```

或者你可以自己去修改元素的z-index

```css
.bro2{
	z-index:1;
}
/*此时这个类名为bro2的盒子就会盖在3的上面.因为其他元素默认的z-index为0.*/
```

七层层级

> **z-idnex为负数==> 背景 ==> 块级元素(block)层级 ==>  float浮动层 ==> 文本(inline/inline-block)层级  ==>  z-index为0/auto  ==>  z-index为正**

1. 同级元素中，后面元素的层级会高于之前层级。

2. 父子元素中，子元素层级会高于父元素层级。



想要改变层级关系，使用z-index，同级元素中z-index越大层级越高。

但z-index不会影响父子元素，父元素调高z-index值也无法比子元素的层级高。

------

定位水平居中盒子的两种方法.

```css
	ul{
			position: relative;
			width: 600px;
			height: 600px;
			margin: 100px auto 0;
			border: 2px solid pink;
		}
		li{
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			margin: auto;/*只设置绝对定位不给偏移量,左右两边的auto会暂时失效*/
			width: 200px;
			height: 200px;
			background-color: pink;
		}
	/*position的方向值全部设置为0,说明小盒子完全能够分配大盒子的空间.
	  小盒子知道了大盒子上下左右的空间.
	  相当于四只手用弹簧拉它,拉力都是一样的.

	  会在小盒子比大盒子大失效,先margin在定位,定位最后执行*/
	<ul>
		<li></li>
	</ul>
```

```css
		ul{
			position: relative;
			width: 600px;
			height: 600px;
			margin: 100px auto 0;
			border: 2px solid pink;
		}
		li{
			position: absolute;
			top: 50%;
			left: 50%;/*先将盒子的左上角推到大盒子的中心点*/
			margin-top: -100px;/*最后平移margin的负值将元素正中心点对准盒子正中心点,实现上														下垂直居中*/
			margin-left: -100px;
			width: 200px;
			height: 200px;
			background-color: pink;
		}
		
```

------



### **伪类**

> hover选择器左侧必须有选择器，右侧的选择器可以设置也可以不设置
>
> 当鼠标放在左侧选择器选中的元素的时候代码才会生效
>
> hover右侧的选择器只能时选择兄弟元素或是子元素(包括兄弟元素的子元素)

**hover右边选择器**

> **中间什么都不加(空格)  控制后代元素；**
>
> **>控制子代元素**
>
> **‘+’控制就近元素 ；**
>
> **‘～’ 控制同级元素（兄弟元素）；**





### CSS优化和样式书写顺序

> 样式还有书写顺序？样式这么简单的东西，不是随便写写就行的么。很多初学者，甚至有一定工作经验的人都会发出这种疑问。而样式的书写顺序到底对页面有没有影响呢？答案是肯定的。如何写出好的css样式也是一个优秀的开发者必须要知道的！而且应该养成习惯，融入到开发中！好的习惯不是一点养成的。

为什么要注意书写顺序？

> 减少浏览器reflow(重排），提升浏览器渲染dom树的性能    

`①:`解析html构建dom树，解析css构建cssom树：将html解析成树形的数据结构，将css解析成树形的数据结构  

`②:`构建render树：DOM树和CSS树合并之后形成的render树。

`③:`布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。

`④:`绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。

css样式解析到显示至浏览器屏幕上就发生在`②③④`步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第`②`步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。

样式的书写顺序是如何影响网页的？

> 比如如下代码：

```css
span{
    width:200px; 
    height:200px;
    background:red;
    display:block;
}
```

当浏览器解析到`display`的时候，突然发现元素是块级元素，而之前是按照行内元素渲染的！这个时候不得不回头重新渲染，在按照块级元素解析span标签。正确的做法是`display`写在样式`最前面`，一开始就以块级元素渲染span标签。

在看一个例子：

```css
.box{
    width:50%;
    height:200px;
    background:blue;
    position:absolute;
}
```

这个例子 解析到`position`的时候，突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，

而绝对定位是根据已经定位的父元素定位的，如果父元素的大小不一样，就会出现.box大小会重新改变的结果，使页面闪动。

定位又是脱离文档流的，浮起来之后可能会影响其他元素排列布局。

`一遍能过的非要渲染两遍 是很浪费性能的,大量的重绘页面会导致页面一闪一闪的，影响用户体验~`





重排(reflow)和重绘(repaint)

- 元素位置是相对的  一个元素位置移动可能改变其他元素位置移动 这个过程就叫reflow
- 一些属性不会影响位置变化  只影响元素外观风格 这个过程被称为repaint

特点

- 重排必将重绘
- 重绘不一定重排



1）定位属性：

```css
.list{
    display
    position( left  top   right  bottom )
    float  
    overflow  
    clear   
    z-index
    content
    list-style
    visibility
    opacity
   } 
```

（2）自身属性：

```css
.list{
    width
    height
    padding 
    border
    margin  
    background
   } 
```

（3）文字样式：

```css
.list{
    color 
    font-family   
    font-size   
    font-style   
    font-weight   
    font-varient    
   } 
```

（4）文本属性：

```css
.list{
    text-align   
    vertical-align   
    text-wrap   
    text-transform   
    text-indent    
    text-decoration   
    letter-spacing    
    word-spacing    
    white-space 
    text-overflow
}   
```

（5）css3中新增属性：

```css
.list{  
    box-shadow
    cursor 
    border-radius  
    background:linear-gradient radial-gradient
    transform……
    animation:
}
```





### **选择器优化**

- 不要使用嵌套过多过于复杂的选择器，保持简单，可以通过样式直接选择，不要画蛇添足。
- 避免过多的通配符选择器
- 移除无匹配的样式

```css
/* 较差的做法 */
ul li a {
    text-decoration: none;
}
ul.list li.list-item a.list-link {
    text-decoration: none;
} 
/* 更好的做法 */
.list-link {
    text-decoration: none;
}

/* 避免过多的通配符选择器 */
/* 少量完全可以 */
* {
    padding: 0;
    margin: 0;
} 

/* 1.4.移除无匹配的样式 */
.list {
} 
```



### **其他优化**

- 提取公用部分
- 避免使用 CSS @import 导入 CSS

```css
/* 提取公用部分 */
/* 较差的做法 */
ol {
    padding: 0;
    margin: 0;
}
p {
    padding: 0;
    margin: 0;
}
/* 更好的做法 */
ol,
p {
    padding: 0;
    margin: 0;
}

<syule>
/* 避免使用 CSS @import 导入 CSS 会发送多余的 HTTP 请求 (less sass里面的@import可以使用 因为相对于拷贝一份代码到当前页面，不会发送额外请求)*/
 @import "./reset.css";
</style>
```

#### 简写css颜色属性值

```cs
/* 不推荐 */
.box{ color:#000000; background-color:#ddeeff; }
/* 推荐 */
.box{ color:#000; background-color:#def;}
```

#### 删除css属性值为0的单位

> 0就是0，任何单位都不需要,只要前面的数值为0,后面的单位都可以去掉 .

```css
/* 不推荐 */
.box{ margin:0px; padding:0px;}
/* 推荐 */
.box{ margin:0; padding:0;}
```

