### 框架设计，为什么要谈权衡？

想象一下，你要做一道菜，既要好吃，又要好看，还得省时间 —— 这不就是在做选择吗？框架设计也是这样。Vue.js 作为一个视图层框架，它的每个模块都不是孤立的，互相之间有联系、有牵制。设计者得先想清楚：我要这个框架干嘛？面向谁？是追求极致性能，还是让开发者用起来更爽？只有把这些“大方向”搞明白，后面的细节设计才不会跑偏。

对我们这些学习框架的人来说也一样。如果光盯着代码细节看，很容易迷失在树林里，忘了抬头看看整片森林。所以，今天咱们就从全局视角出发，聊聊框架设计里的两种范式 —— 命令式和声明式，还有性能跟可维护性之间的博弈，最后再看看虚拟 DOM 到底是怎么回事。



### 命令式 vs 声明式：过程和结果的较量

命令式就像你一步步告诉电脑“怎么做”。比如早年的 jQuery，你要操作页面，可能得这么写：

```js
$('#app')
  .text('hello world')
  .on('click', () => { alert('ok') })
```

这段代码就像在说：“嘿，找到那个 div，把文字改成 'hello world'，再给它加个点击事件，点的时候弹个 'ok'。”整个过程你得自己管，电脑就老老实实照着干。用原生 JavaScript 也差不多：

```js
const div = document.querySelector('#app')
div.innerText = 'hello world'
div.addEventListener('click', () => { alert('ok') })
```

这种方式很符合我们的思维逻辑 —— 想干啥就干啥。

那声明式呢？它就不一样了，关注的不是“怎么做”，而是“我想要啥”。拿 Vue.js 举例，同样的需求，你只需要写：

```html
<div @click="() => alert('ok')">hello world</div>
```

你就告诉 Vue：“我想要个 div，里面是 'hello world'，点击时弹个 'ok'。”至于怎么实现，Vue 在背后默默搞定。这就像你在饭店点菜，告诉服务员“我要一碗牛肉面”，至于厨师怎么和面、怎么炖汤，你才不管呢。

所以，命令式是“过程导向”，声明式是“结果导向”。Vue 表面上给我们的是声明式的体验，但它内部肯定得用命令式的方式去操作 DOM，不然怎么把页面渲染出来呢？这就引出了一个问题：两种方式到底哪个更好？



### 性能 vs 可维护性：鱼和熊掌怎么选？

说到“更好”，咱得从两方面看：性能和可维护性。先说个结论：命令式代码的性能理论上比声明式强。为什么？很简单，命令式是你自己动手，直接改，想改啥改啥。比如要把文字改成 'hello vue3'：

```js
div.textContent = 'hello vue3'
```

就这一句，干净利落，性能几乎没法再优了。因为你知道改的是啥，只动那块就行。

但声明式呢？它得先搞清楚前后差别在哪。以 Vue 为例，模板从：

```html
<div @click="() => alert('ok')">hello world</div>
```

变成：

```html
<div @click="() => alert('ok')">hello vue3</div>
```

Vue 得对比一下，找出“hello world”和“hello vue3”的区别，最后还是得执行类似 div.textContent = 'hello vue3' 的操作。假设直接改的性能消耗是 A，找差别的消耗是 B，那命令式就是 A，声明式就是 A + B，多出来的 B 就是性能的“代价”。

那为什么 Vue 还要选声明式呢？因为可维护性啊！用命令式写代码，你得自己管 DOM 的创建、更新、删除，项目一大，代码就容易乱成一团。而声明式呢，你只管描述结果，过程交给框架，代码简洁多了，维护起来也省心。这就是权衡：性能上让步一点，换来开发体验的大提升。



### 虚拟 DOM：性能和便利的折中方案

说到声明式的性能优化，就得提虚拟 DOM 了。啥是虚拟 DOM？简单说，就是用 JavaScript 对象模拟真实 DOM，先算出变化，再更新页面。这样就能尽量减少找差别的成本 B，让声明式的性能尽量靠近命令式。

但别误会，虚拟 DOM 的性能还是比不上极致优化的原生 DOM 操作。为啥？因为它多了一层计算：先建虚拟 DOM，再比对，再更新。不过现实中，写出极致优化的命令式代码太费劲了，尤其在大项目里，性价比不高。虚拟 DOM 就厉害在这儿——它让开发者写声明式代码，既省心，又保证性能不会太差。

那跟老方法 innerHTML 比呢？用 innerHTML 更新页面，得重新拼字符串，再整个替换，比如：

```js
div.innerHTML = '<span>hello vue3</span>'
```

哪怕只改一个字，也得全量重建 DOM，页面越大，消耗越高。而虚拟 DOM 只改变化的部分，效率一下子就上来了。所以在更新场景下，虚拟 DOM 完胜 innerHTML，虽然它比不上原生 createElement 的极致性能，但在便利性和性能之间找到了平衡。



### 总结：权衡无处不在

聊到这儿，你应该看出来了，框架设计就是一门“取舍的艺术”。命令式性能强但费脑子，声明式省心但有性能损耗，虚拟 DOM 则是两者的折中。Vue.js 选择声明式+虚拟 DOM，就是在可维护性和性能之间找了个舒服的点。