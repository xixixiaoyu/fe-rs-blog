### 组件是怎么被渲染的？

你可能知道，Vue 的核心是个渲染器，它负责把虚拟 DOM（也就是我们写的那些描述界面的对象）变成浏览器里能看到的真实 DOM。比如一个简单的 `<div>` 标签，虚拟 DOM 长这样：

```js
const vnode = {
  type: 'div',
  children: 'Hello World'
}
```

渲染器看到 type 是字符串 'div'，就知道这是个普通标签，直接创建 DOM 节点挂上去。但组件呢？

它跟普通标签不一样。组件本质上是个对象，里面定义了数据、渲染逻辑啥的。假设我们有个组件：

```js
const MyComponent = {
  name: 'MyComponent',
  render() {
    return {
      type: 'div',
      children: '我是组件'
    }
  }
}
```

当我们用它时，虚拟 DOM 是这样的：

```js
const vnode = {
  type: MyComponent
}
```

注意这里的 type 不是字符串，而是组件对象本身。渲染器一看 type 是个对象，就知道这是个组件，得特殊处理。它会调用 mountComponent 函数来挂载组件。这个函数干啥呢？简单说：

1. 从 vnode.type 拿到组件对象。
2. 调用组件的 render 函数，生成虚拟 DOM（比如上面的 'div'）。
3. 再用 patch 函数把这个虚拟 DOM 渲染成真实 DOM。

代码实现：

```js
function mountComponent(vnode, container) {
  const componentOptions = vnode.type
  const { render } = componentOptions
  const subTree = render()
  patch(null, subTree, container)
}
```

就这样，一个组件就被渲染出来了。是不是挺简单？



### 组件状态与自更新：让它动起来

光渲染一次没啥意思，组件得有自己的状态，还得能更新。比如我们加个 data：

```js
const MyComponent = {
  data() {
    return { foo: 'hello world' }
  },
  render() {
    return {
      type: 'div',
      children: `foo 的值是: ${this.foo}`
    }
  }
}
```

这里 data 返回组件的状态，我们希望 foo 变了，页面也能跟着变。怎么做呢？Vue 用的是响应式系统。简单说，就是把 data 返回的对象变成响应式的（用 reactive 函数），然后在渲染时绑定到 this 上：

```js
function mountComponent(vnode, container) {
  const { render, data } = vnode.type
  const state = reactive(data())
  const subTree = render.call(state, state)
  patch(null, subTree, container)
}
```

但光有状态还不够，得让它自动更新。Vue 用了个叫 effect 的东西，把渲染过程包起来：

```js
effect(() => {
  const subTree = render.call(state, state)
  patch(null, subTree, container)
})
```

effect 的作用是，一旦 state 里的数据变了（比如 state.foo = 'new value'），它就重新跑一遍里面的代码，页面就更新了。

不过有个问题：如果短时间内改了好几次 foo，渲染会跑好多次，太浪费性能了。Vue 的解决办法是用调度器，把更新任务攒起来，只跑一次。代码大概这样：

```js
const queue = new Set()
let isFlushing = false
const p = Promise.resolve()

function queueJob(job) {
  queue.add(job)
  if (!isFlushing) {
    isFlushing = true
    p.then(() => {
      try {
        queue.forEach(job => job())
      } finally {
        isFlushing = false
        queue.clear()
      }
    })
  }
}

effect(() => {
  const subTree = render.call(state, state)
  patch(null, subTree, container)
}, { scheduler: queueJob })
```

