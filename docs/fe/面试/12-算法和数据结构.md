## 1.大数相加

```js
var add = function(a, b) {
    const maxLength = Math.max(a.length, b.length);
    let sum = "";
    let overflow = false;
    for(let i = 1; i <= maxLength; i++) {
        const ai = a[a.length - i] || "0";
        const bi = b[b.length - i] || "0";
        let ci = parseInt(ai) + parseInt(bi) + (overflow ? 1 : 0);
        overflow = ci >= 10;
        ci = overflow ? ci - 10 : ci;
        sum = ci + sum;
    }
    sum = overflow ? "1" + sum : sum;
    return sum;
};

console.log(add("11111111101234567","77777777707654321"))
console.log(add("911111111101234567","77777777707654321"))
```



![image-20220424015747866](C:\Users\14169\AppData\Roaming\Typora\typora-user-images\image-20220424015747866.png)

## 2.两数之和

```js
var twoSum = function(nums, target) {
    // 存储遍历的每位数字和对应下标
    const map = {};
    for(let i = 0; i < nums.length; i++) {
        const number = nums[i];
        // 要寻找目标数字
        const targetNumber = target - number;
        // 如果目标数字存在于对象
        if(targetNumber in map) {
            // 返回对象中对应下标和目前的下标
            return [map[targetNumber], i]
        }else {
            // 不存在则存入对应数字和下标
            map[number] = i;
        }
    }
    // 没找到返回空数组
    return []
};
```







## 3.无重复最长子串的长度

滑动窗口法：

```js
var lengthOfLongestSubstring = function(s){
  if(s.length <= 1) return s.length
  let max = 0
  let p1 = 0
  let p2 = 1
  while(p2 < s.length) {
    let sameIndex = -1
    for(let i = p1; i < p2; i++){
      if(s[i] === s[p2]){
        sameIndex = i
        break
      }
    }
    let tempMax 
	  if( sameIndex >= 0){
	    tempMax = p2 - p1
	    p1 = sameIndex + 1
	  }else{
	    tempMax = p2 - p1 + 1
	  }
	  if(tempMax > max){
	    max = tempMax
	  }
    p2 += 1
  }
  
  return max
}
```





## 4.有效括号

```js
var isValid = function(s) {
    // 如果为奇数
    if(s.length % 2 === 1) return false;
    const stack = [];
    for(let i = 0; i < s.length; i++) {
        const c = s[i];
        if(c === "(" || c === "[" || c === "{") {
            stack.push(c)
        }else {
            const t = stack[stack.length -1];
            if((t === "(" && c === ")") 
                || (t === "{" && c === "}")
                || (t === "[" && c === "]")) {
                    stack.pop();
            }else {
                return false;
            }
        }
    }
    return stack.length === 0;
};
```





## 5.反转链表

```js
var reverseList = function(head) {
    // 双指针
    let p1 = head;
    let p2 = null;
    while(p1) {
        // 保存 p1.next
        const temp = p1.next;
        // 将 p1.next 指向 p2
        p1.next = p2;
        p2 = p1;
        p1 = temp;
    }
    return p2;
};
```





## 6.删除链表节点

```js
var deleteNode = function(node) {
    // 当前节点的值赋值为下个节点的值
    node.val = node.next.val;
    // 将当前节点指针指向下下个节点，以达到删除下个节点的操作
    node.next = node.next.next;
};
```

