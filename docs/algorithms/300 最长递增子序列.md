最长递增子序列”要求找出给定数组中最长递增子序列的长度。子序列是指在不改变元素间相对顺序的情况下，从原序列中删除一些元素（也可以不删除）后形成的序列。<br />例如，给定数组 nums = [10, 9, 2, 5, 3, 7, 101, 18]，最长递增子序列是 [2, 3, 7, 101] 或 [2, 5, 7, 101]，因此答案是 4。

使用动态规划，动态规划的思想是使用一个数组 dp 来保存到当前位置为止最长递增子序列的长度。<br />对于数组中的每一个数 nums[i]，我们从 0 到 i-1 遍历，如果存在一个数 nums[j] 小于 nums[i]，则 nums[i] 可以接在 nums[j] 后面形成更长的递增子序列。<br />因此，dp[i] 应该是所有 dp[j] + 1 的最大值（其中 0 <= j < i 且 nums[j] < nums[i]）。最后，整个数组中的最大 dp 值就是我们要找的最长递增子序列的长度。
```javascript
function lengthOfLIS(nums) {
	if (nums.length === 0) return 0;
	// 初始化 dp 数组，所有元素为 1，因为最短的递增子序列包含它自己
	const dp = new Array(nums.length).fill(1);
	let maxLen = 1;
	for (let i = 1; i < nums.length; i++) {
		for (let j = 0; j < i; j++) {
			// 如果找到小于当前元素的，尝试更新 dp[i]
			if (nums[j] < nums[i]) {
				dp[i] = Math.max(dp[i], dp[j] + 1);
			}
		}
		// 更新全局最大长度
		maxLen = Math.max(maxLen, dp[i]);
	}
	return maxLen;
}
```
使用上面的例子 [10, 9, 2, 5, 3, 7, 101, 18]，初始化 dp 为 [1, 1, 1, 1, 1, 1, 1, 1]。然后按照动态规划的状态转移方程更新 dp：

- 当 i = 3（元素5），j = 2（元素2），因为 5 > 2，所以 dp[3] = max(dp[3], dp[2] + 1) = 2。
- 当 i = 5（元素7），j = 2（元素2），同样地 dp[5] = max(dp[5], dp[2] + 1) = 2，但当 j = 3（元素5），dp[5] = max(dp[5], dp[3] + 1) = 3。
- 以此类推，直到完成所有元素的遍历。

遍历完成后，dp 数组变成 [1, 1, 1, 2, 2, 3, 4, 3]，其中最大值 4 就是最长递增子序列的长度。

- 外层循环遍历了 nums 数组一次，时间复杂度为 O(n)；
- 内层循环在每次外层循环中都会执行，最坏情况下时间复杂度为 O(n^2)；
- 因此，整个算法的时间复杂度为 O(n^2)。
