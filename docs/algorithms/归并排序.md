归并排序是一种高效的排序算法，它基于分治法（Divide and Conquer）的一个典型应用。归并排序的基本思想是将一个大数组分割成两个小数组去解决。然后递归地将这些小数组分割成更小的数组，直到每个小数组只有一个元素，接着将这些数组两两合并，保证合并后仍然有序，最终得到一个完全排序的数组。

归并排序的实现步骤如下：

1. **分割**：将数组从中间分割成前后两部分，然后对前后两部分分别进行排序。
2. **递归**：对分割后的两部分继续递归执行分割，直至每个部分只有一个元素。
3. **合并**：将两个排序好的部分合并成一个排序好的数组。

下面是归并排序的 JavaScript 代码实现，其中包括分割（mergeSort 函数）和合并（merge 函数）两个主要部分：
```javascript
function mergeSort(arr) {
    if (arr.length < 2) {
        return arr; // 基本结束条件，当数组长度为1时，直接返回数组
    }

    const middle = Math.floor(arr.length / 2); // 找到中间索引
    const left = arr.slice(0, middle); // 分割数组的左半部分
    const right = arr.slice(middle); // 分割数组的右半部分

    return merge(mergeSort(left), mergeSort(right)); // 递归排序左右两半，并合并结果
}

function merge(left, right) {
    let result = [];
    let leftIndex = 0;
    let rightIndex = 0;

    // 合并两个数组
    while (leftIndex < left.length && rightIndex < right.length) {
        if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex++]); // 将左数组的当前元素添加到结果数组，并移动索引
        } else {
            result.push(right[rightIndex++]); // 将右数组的当前元素添加到结果数组，并移动索引
        }
    }

    // 合并剩余的元素（如果有的话）
    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}
```
举例说明：<br />假设我们有一个数组 [3, 1, 4, 1, 5, 9, 2, 6]，归并排序的过程如下：

1. 分解：[3, 1, 4, 1] 和 [5, 9, 2, 6]
2. 继续分解：
   - [3, 1] 和 [4, 1]
   - [5, 9] 和 [2, 6]
3. 继续分解直到数组长度为1：
   - [3] [1] [4] [1]
   - [5] [9] [2] [6]
4. 合并：
   - [1, 3] [1, 4]
   - [5, 9] [2, 6]
5. 继续合并：
   - [1, 1, 3, 4]
   - [2, 5, 6, 9]
6. 最终合并得到排序后的数组：[1, 1, 2, 3, 4, 5, 6, 9]

<br />由于归并排序每次都将数组分成两半，所以分解阶段的深度是 O(log n)，其中 n 是数组的长度。每一层的合并操作总共需要 O(n) 的时间，因此归并排序的总时间复杂度是每层的时间复杂度乘以层数，即 O(n log n)。
