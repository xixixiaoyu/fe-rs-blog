题目“和为 K 的子数组”要求我们找到数组中所有连续的子数组，它们的元素和等于给定的值 K。比如，如果输入数组为 [1, 2, 3]，K 为 3，那么存在两个子数组的和为 3：[1, 2] 和 [3]。

使用哈希表来记录前缀和的出现频率。前缀和是指从数组第一个元素到当前元素的所有元素的和。

- 我们可以遍历数组，计算当前的前缀和，并在哈希表中查找是否存在前缀和等于当前前缀和减去 K 的元素。
- 如果存在，那么就找到了一个和为 K 的子数组。
- 每次遍历时，我们都需要在哈希表中更新当前前缀和的频率。
```javascript
function subarraySum(nums, k) {
    const map = new Map();
    map.set(0, 1); // 初始化为前缀和为0的有一个
    let sum = 0;   // 当前前缀和
    let count = 0; // 和为k的子数组计数

    for (let num of nums) {
        sum += num; // 更新前缀和
        if (map.has(sum - k)) {
            count += map.get(sum - k); // 如果存在这样的前缀和，更新计数
        }
        map.set(sum, (map.get(sum) || 0) + 1); // 更新哈希表中前缀和的频率
    }

    return count;
}
```
例如，输入数组为 [1, 1, 1]，K 为 2。初始化哈希表 map 为 {0: 1}，表示前缀和为 0 的子数组有 1 个。

- 第一次遍历时，sum = 1，map 更新为 {0: 1, 1: 1}，没有找到满足条件的子数组。
- 第二次遍历时，sum = 2，map 更新为 {0: 1, 1: 1, 2: 1}，发现 sum - k = 0，在 map 中存在，计数 count 更新为 1。
- 第三次遍历时，sum = 3，map 更新为 {0: 1, 1: 1, 2: 1, 3: 1}，发现 sum - k = 1，在 map 中存在，计数 count 更新为 2。

最终，返回计数 count 的值 2。

这段代码的时间复杂度主要取决于数组的遍历，只需要遍历一次数组，因此时间复杂度为 O(n)，其中 n 是数组的长度。在遍历过程中，我们对哈希表的查找和更新操作的时间复杂度都是 O(1)，因此整体时间复杂度保持为 O(n)。

