“每日温度”要求我们根据一个整数数组 temperatures，代表每天的温度，返回一个数组，计算对于每一天，至少需要等多少天才能等到一个更暖和的气温。如果未来没有更暖和的天气，填 0。

例如，给定 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。这意味着第一天的温度为 73，第二天的温度为 74，比第一天暖和，所以只要等 1 天就能感受到更暖和的天气。对于第三天，温度为 75，要等到第七天的温度升到 76，才会更暖和，所以需要等 4 天。

使用单调栈的解题思路，单调栈可以帮助我们维护一个元素递减的栈结构。

- 我们从左到右遍历温度数组，对于每个元素，我们将其索引推入栈中。
- 如果当前元素比栈顶元素代表的温度高，那么我们就找到了栈顶元素右边第一个更高的温度，计算两者之间的距离，并将栈顶元素弹出。
- 重复这个过程，直到当前元素不再比栈顶元素大，或者栈为空。
```javascript
function dailyTemperatures(temperatures) {
    let len = temperatures.length;
    let ans = new Array(len).fill(0); // 初始化结果数组，全部填充为 0
    let stack = []; // 初始化一个栈，用来存放索引

    for (let i = 0; i < len; i++) {
        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            // 当前温度比栈顶温度高时，计算索引差值
            let index = stack.pop(); // 弹出栈顶元素
            ans[index] = i - index; // 计算等待天数
        }
        stack.push(i); // 将当前温度的索引入栈
    }
    return ans;
}
```
假设 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，我们逐步分析代码执行的过程：

- 初始化 ans 为 [0, 0, 0, 0, 0, 0, 0, 0] 和 stack 为空。
- 遍历数组，i = 0 时，栈为空，直接将索引 0 入栈。
- i = 1 时，temperatures[1] 是 74，比栈顶元素代表的温度 73 高，弹出栈顶，ans[0] 更新为 1 - 0 = 1，然后将索引 1 入栈。
- i = 2 时，temperatures[2] 是 75，比栈顶元素代表的温度 74 高，弹出栈顶，ans[1] 更新为 2 - 1 = 1，然后将索引 2 入栈。
- 以此类推，直到数组遍历完成。

最终得到的 ans 就是 [1, 1, 4, 2, 1, 1, 0, 0]。

在这个算法中，每个元素最多被推入栈一次，出栈一次，因此时间复杂度为 O(N)，其中 N 是温度数组的长度。尽管看起来有一个嵌套的 while 循环，但实际上每个元素只会被处理两次（一次推入，一次弹出），因此总的时间复杂度保持在 O(N)。

