“股票价格跨度”要求我们设计一个股票价格跨度系统，用来计算股票价格在连续下跌天数内的跨度。<br />具体来说，这个系统需要实现一个 StockSpanner 类和一个 next 方法。next 方法接收今天的股票价格作为参数，并返回股票价格连续下跌的天数，包括今天。<br />假设我们有一个价格序列 [100, 80, 60, 70, 60, 75, 85]，我们调用 next 方法的返回结果应该是 [1, 1, 1, 2, 1, 4, 6]。

- 第一天的股票价格是 100，没有比它低的，所以跨度是 1。
- 第二天的价格是 80，比前一天低，所以跨度是 1。
- 第三天的价格是 60，比前两天都低，所以跨度是 1。
- 第四天的价格是 70，比第三天的 60 高，所以跨度是 2（包括第三天和第四天）。
- 以此类推。

<br />我们可以使用一个栈来存储价格和对应的跨度。栈中的元素保持单调递减的顺序，这样我们在计算新的价格跨度时，可以快速地弹出栈中比当前价格低的元素。
```javascript
class StockSpanner {
    constructor() {
        this.stack = [];
    }

    next(price) {
        let span = 1;
        // 当栈不为空且栈顶的价格小于等于今天的价格时，弹出栈顶元素
        while (this.stack.length > 0 && this.stack[this.stack.length - 1][0] <= price) {
            // 弹出元素的跨度累加到今天的跨度
            span += this.stack.pop()[1];
        }
        // 将今天的价格和跨度作为一个对压入栈中
        this.stack.push([price, span]);
        // 返回今天的跨度
        return span;
    }
}
```
假设我们有一系列股票价格，按天输入：[100, 80, 60, 70, 60, 75, 85]。我们用 StockSpanner 类来处理这些价格，并且调用 next 方法来计算跨度。

- 第一天，价格是 100，栈为空，所以跨度是 1，栈中元素变为 [[100, 1]]。
- 第二天，价格是 80，栈顶价格 100 大于 80，所以跨度是 1，栈中元素变为 [[100, 1], [80, 1]]。
- 第三天，价格是 60，同理，跨度是 1，栈中元素变为 [[100, 1], [80, 1], [60, 1]]。
- 第四天，价格是 70，栈顶价格 60 小于 70，弹出栈顶元素，跨度变为 1+1=2，并且栈顶价格 80 仍然大于 70，所以跨度保持不变，栈中元素变为 [[100, 1], [80, 1], [70, 2]]。
- 以此类推，我们可以计算出后续价格的跨度。

时间复杂度分析：

- next 方法的时间复杂度为 O(N) 的最坏情况，其中 N 是调用 next 方法的次数。
- 因为每个元素最多只会被压入和弹出栈一次，所以 N 次调用 next 方法的总时间复杂度是 O(N)。
- 平均情况下，每次调用 next 方法的时间复杂度接近 O(1)。
