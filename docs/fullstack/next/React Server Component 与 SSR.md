# 探索 Next.js v13：React Server Components 与 SSR 的碰撞

## 前言

Next.js v13 的发布带来了一个颠覆性的更新——基于 React Server Components 的 App Router 路由解决方案。这不仅是 Next.js 的一次重大进化，更是 React 社区多年来对 React Server Components（RSC）概念的真正落地。对于开发者来说，这意味着我们需要重新思考如何在服务端和客户端之间分配渲染任务。

在这篇文章中，我们将从 React Server Components 的背景出发，逐步探讨它与 Server-side Rendering（SSR）的区别，帮助大家更好地理解和使用服务端组件与客户端组件。

## React Server Components 的诞生

2020 年 12 月，React 团队发布了关于 React Server Components 的介绍，详细阐述了其背景和使用方式。Dan Abramov 在演讲中提到，应用开发中有三大核心要素：**用户体验、易于维护和高性能**。然而，这三者往往难以兼顾。

以 Spotify 的音乐家介绍页面为例，页面包含热门单曲和唱片目录两个区域。传统的 React 开发方式通常需要在顶层获取数据，然后通过 props 传递给子组件。这种方式虽然简洁，但随着项目的迭代，代码的维护成本会逐渐增加，甚至可能导致冗余数据或错误。

为了解决这个问题，开发者可能会选择让每个组件各自负责数据请求，但这又会带来性能问题，尤其是当多个请求需要串行处理时，页面加载速度会显著下降。

### React Server Components 的解决方案

React Server Components 的出现，正是为了解决这个困境。它将数据请求的逻辑放在服务端，由服务端直接返回带有数据的组件。这样，客户端不再需要发起多次 HTTP 请求，页面的加载速度得以提升。

在使用 React Server Components 后，React 树的结构会发生变化。服务端渲染的组件会以基础 HTML 标签和客户端组件占位符的形式返回给客户端。客户端接收到这些数据后，会根据实际情况重建 React 树，并用真正的客户端组件填充占位符，最终渲染出完整的页面。

这种方式不仅减少了客户端的 JavaScript 包大小，还允许服务端组件直接访问后端资源，进一步提升了性能。

## Server-side Rendering 的局限

在 Next.js v12 及之前的版本中，SSR 是通过 `getServerSideProps` 方法在页面层级获取数据，并将整个组件树在服务端渲染为 HTML。虽然这种方式可以加快页面的初次加载，但它也有一些明显的缺点：

1. **数据获取必须在组件渲染之前完成**。
2. **组件的 JavaScript 必须先加载到客户端，才能开始水合（Hydration）**。
3. **所有组件必须先水合，才能与用户交互**。

这些步骤是串行执行的，如果某个环节变慢，整个页面的加载速度都会受到影响。此外，SSR 只在页面的初次加载时发挥作用，对于后续的交互和数据更新，SSR 并无帮助。

## RSC 与 SSR 的区别

表面上看，React Server Components 和 Server-side Rendering 都是在服务端进行渲染，目的都是加快页面的加载速度。但实际上，这两者是完全独立的技术，可以单独使用，也可以结合在一起使用。

- **SSR 的重点在于渲染整个页面**，它将组件渲染为 HTML 并发送给客户端。
- **RSC 的重点在于组件的细粒度渲染**，它将组件渲染为一种特殊的格式（RSC Payload），并在客户端请求相关组件时返回。

RSC 的最大优势在于它可以保持客户端的状态。每次 SSR 渲染都会生成一个新的 HTML 页面，导致状态丢失。而 RSC 则通过特殊的格式，允许客户端多次重新获取数据并更新 UI，而不会丢失状态。

## Next.js v13 的融合

Next.js v13 将 RSC 和 SSR 结合在一起，提供了更高效的渲染方式。通过区分服务端组件和客户端组件，开发者可以根据实际需求选择最合适的渲染方式，既能享受 RSC 带来的性能提升，又能利用 SSR 的优势。

## 总结

React Server Components 的引入，标志着前端开发进入了一个新的阶段。它不仅解决了传统 SSR 的一些痛点，还为开发者提供了更灵活的渲染方式。通过这篇文章的介绍，相信大家对 RSC 和 SSR 的区别有了更清晰的认识。在接下来的开发中，合理利用这两种技术，将帮助我们构建出更高效、更易维护的应用。

Next.js v13 的发布，意味着我们可以更轻松地在服务端和客户端之间分配渲染任务，打造出更快、更流畅的用户体验。未来，随着 RSC 的不断发展，前端开发的边界将被进一步拓宽。
