最早的前端，是服务端通过模板引擎填充数据渲染出来的。<br />后面有了 ajax ,我们可以异步请求数据，服务端返回 json（xml 格式啰嗦所以被废弃） 数据，浏览器拼接 html 后渲染更新局部页面。<br />早期使用原生 js 的时候会做各种原生 dom 操作，jq 是为了简化 dom 操作的，基本流程就是我们拿到数据处理后渲染 dom，数据改变更新 dom。我将 dom 这层称为物理层。数据处理称为逻辑层。<br />后面出现一系列 vue、react 等前端框架，它们的核心是组件化，以及状态驱动视图。我们只需要提供数据，渲染更新的细节就交给框架就行了。所以现在前端基本不会再关心物理层的 dom 操作了，而是专注于逻辑层处理即可。<br />vue 使用 template 的 dsl 创建视图，react 则通过 jsx（babel 实现）。形式不同，最后都是转化为类似 render 函数创建 vdom，然后映射为真实 dom。<br />视图的更新差异导致两者架构的不同走向，vue 通过劫持数据实现响应式，数据变化，精确的递归更新渲染对应组件，react 则是提供对应的 api 调用更新，因为性能太差，创造了 fiber 架构，把 vdom 转换为 fiber，，通过对比新旧 fiber 差异更新，这样为什么能优化性能？因为 fiber 本质是种链表结构，没有了 parent、children 这种属性，多了 child、sibling、return 属性，对比的时候可以使用循环，随时可打断对比（因为打断后还能通过记录在 fiber 上的兄弟父亲关系继续循环对比），然后执行优先级更高的任务，每次对比会把差异推到一个队列中，在对比完后统一遍历队列更新（不可打断）。<br />组件逻辑的复用，vue2 使用 mixin 的方式，react 使用 HOC 和 render props ，现在最新版本，它们都是采用函数 hooks 的方式抽离公共逻辑。<br />现在的单页应用基本采用浏览器渲染(csr)方案，从服务端获取脚本，然后再动态创建 dom，对于低端机和需要 seo 的网页，我们仍然需要服务端渲染(ssr)的方案，我们可以基于同一个组件树，把它渲染成 html 字符串，这样服务端渲染和浏览器渲染都用的同样的组件代码，这就是同构的方案。<br />我们可以发现世界似乎是一个轮回，从最开始服务端渲染，到客户端渲染，然后出现逻辑层的组件方案，最后又基于组件方案实现服务端渲染，物理层东西一直没变，逻辑层却不断地添加，这一切似乎只为了两个字，提效。<br />我们回到之前说的逻辑层，这个层的核心是什么呢？没错，就是数据处理，也可以说是状态管理。<br />我觉得衡量一个程序员水平的唯一标准就是数据的处理水平，时间空间复杂度越低，相同性能复杂度，代码量越少肯定是越好。<br />可以说，理解了状态管理就理解了前端开发的核心。<br />状态变化前后我们都会做处理，比如状态变化前会对异步过程做管理，状态变化后会做一些联动处理，比如渲染视图或执行某段逻辑。<br />变化前比如 react 的 setState 不会立刻修改状态，而是异步的对状态进行合并处理，redux 的 action 在修改全局 state 也会经历中间件处理，vue 我们修改数据也不会马上生效，也会做合并后一次性更新，vuex 也需要先 dispatch 才能 commit。<br />修改了状态后，往往会触发视图的渲染，vue 的 data 修改之后会重新渲染视图、并且可能会执行 computed 和 watch 逻辑和其他生命周期函数的执行，react 也是如此，这些是状态变化后的联动处理的管理。<br />状态管理也有不同的实现思路，主要就是两种，一种是提供 api 触发状态修改，另一种就是对状态对象做一层代理，代理其 get，set 进行依赖收集触发。<br />组件之间进行状态管理，最简单就是通过 props 传递 state，如果隔了很多层，react 提供了 Context，vue 提供了 Event Bus。但 Context 和 Event Bus 都只做到了状态变化后的联动处理，但是没有对状态变化前的异步代码管理做支持。比如多个组件都修改 context 的值或者 eventbus 修改全局状态，这个过程中执行一个异步的 loading 展示，那多个组件如何复用这个 loading 逻辑呢？这时候我们可以用全局状态管理库，react 有 zustand、redux、mobox，vue 则有 vuex、pinia。











